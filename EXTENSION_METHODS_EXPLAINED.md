# üéì M√©todos de Extensi√≥n en C# - Explicaci√≥n Completa

## ‚ùì La Pregunta Com√∫n

**"¬øPor qu√© puedo usar `services.AddApplicationLayer()` sin hacer `DependencyInjection.AddApplicationLayer(services)`?"**

## üéØ Respuesta Corta

Porque `AddApplicationLayer` es un **m√©todo de extensi√≥n**, no un m√©todo est√°tico normal.

---

## üìö Explicaci√≥n Detallada

### 1Ô∏è‚É£ **¬øQu√© es un M√©todo de Extensi√≥n?**

Un m√©todo de extensi√≥n permite "agregar" m√©todos a tipos existentes **sin modificar el c√≥digo original** de esos tipos.

```csharp
// Sin m√©todos de extensi√≥n, NO puedes hacer esto:
IServiceCollection services = new ServiceCollection();
services.MiMetodoPersonalizado(); // ‚ùå Error: IServiceCollection no tiene este m√©todo

// Pero con m√©todos de extensi√≥n, ¬°S√ç puedes!
public static class MisExtensiones
{
    public static IServiceCollection MiMetodoPersonalizado(this IServiceCollection services)
    {
        // Ahora s√≠ funciona ‚úÖ
        return services;
    }
}
```

### 2Ô∏è‚É£ **Sintaxis: La Palabra Clave `this`**

```csharp
public static class DependencyInjection
{
    // ‚¨áÔ∏è Este "this" es la clave
    public static IServiceCollection AddApplicationLayer(this IServiceCollection services)
    {
        services.AddScoped<IProductService, ProductService>();
        return services;
    }
}
```

**El `this` significa:**
- Este m√©todo "extiende" la clase `IServiceCollection`
- Se puede llamar como si fuera un m√©todo de instancia

### 3Ô∏è‚É£ **¬øC√≥mo Funciona Internamente?**

```csharp
// üñäÔ∏è T√ö ESCRIBES:
services.AddApplicationLayer();

// üîÑ EL COMPILADOR LO CONVIERTE EN:
DependencyInjection.AddApplicationLayer(services);

// ‚ú® Es "syntax sugar" (az√∫car sint√°ctico)
```

### 4Ô∏è‚É£ **Requisitos para Usar M√©todos de Extensi√≥n**

Para que funcione, necesitas:

#### ‚úÖ **1. La clase debe ser static**
```csharp
public static class DependencyInjection // ‚Üê static
{
    // ...
}
```

#### ‚úÖ **2. El m√©todo debe ser static**
```csharp
public static IServiceCollection AddApplicationLayer(...) // ‚Üê static
```

#### ‚úÖ **3. El primer par√°metro debe tener `this`**
```csharp
public static IServiceCollection AddApplicationLayer(this IServiceCollection services)
                                                    // ‚Üë this
```

#### ‚úÖ **4. Importar el namespace**
```csharp
using Application.DependencyInjection; // ‚Üê Sin esto, no funciona
```

---

## üî¨ Comparaci√≥n: Con vs Sin M√©todos de Extensi√≥n

### ‚ùå **Sin M√©todos de Extensi√≥n (M√©todo Est√°tico Normal)**

```csharp
// Definici√≥n - SIN "this"
public static class DependencyInjection
{
    public static IServiceCollection AddApplicationLayer(IServiceCollection services)
    {
        services.AddScoped<IProductService, ProductService>();
        return services;
    }
}

// Uso - VERBOSO y menos elegante
var services = new ServiceCollection();
DependencyInjection.AddApplicationLayer(services);
InfrastructureDI.AddInfrastructureLayer(services);
services.AddControllers();
```

### ‚úÖ **Con M√©todos de Extensi√≥n (Lo Que Usamos)**

```csharp
// Definici√≥n - CON "this"
public static class DependencyInjection
{
    public static IServiceCollection AddApplicationLayer(this IServiceCollection services)
    {
        services.AddScoped<IProductService, ProductService>();
        return services;
    }
}

// Uso - LIMPIO Y FLUIDO (Method Chaining)
var services = new ServiceCollection();
services.AddApplicationLayer()
        .AddInfrastructureLayer()
        .AddControllers();
```

---

## üé® Ventajas de los M√©todos de Extensi√≥n

### 1Ô∏è‚É£ **C√≥digo M√°s Legible (Fluent API)**
```csharp
// ‚úÖ Legible - Se lee como una oraci√≥n en ingl√©s
builder.Services
    .AddApplicationLayer()
    .AddInfrastructureLayer()
    .AddSwaggerGen();

// ‚ùå Menos legible y m√°s verboso
DependencyInjection.AddApplicationLayer(builder.Services);
InfrastructureDI.AddInfrastructureLayer(builder.Services);
builder.Services.AddSwaggerGen();
```

### 2Ô∏è‚É£ **Organizaci√≥n por Namespace**
```csharp
// Cada capa expone sus servicios en su propio namespace
using Application.DependencyInjection;
using Infrastructure.DependencyInjection;

// Y los usa de forma consistente
services.AddApplicationLayer();
services.AddInfrastructureLayer();
```

### 3Ô∏è‚É£ **Encapsulaci√≥n de Detalles**
```csharp
// La capa Application esconde sus detalles de implementaci√≥n
public static IServiceCollection AddApplicationLayer(this IServiceCollection services)
{
    // Nadie fuera de Application necesita saber estos detalles internos
    services.AddScoped<IProductService, ProductService>();
    services.AddScoped<IOtroServicio, OtroServicio>();
    services.AddAutoMapper(Assembly.GetExecutingAssembly());
    services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
    
    return services;
}
```

### 4Ô∏è‚É£ **Consistencia con .NET Framework**
```csharp
// Microsoft usa este mismo patr√≥n en TODO .NET:
services.AddControllers();          // ASP.NET Core
services.AddDbContext<T>();          // Entity Framework Core
services.AddSwaggerGen();            // Swashbuckle
services.AddAuthentication();        // Identity

// Tu c√≥digo sigue el MISMO patr√≥n est√°ndar de .NET:
services.AddApplicationLayer();      // Tu capa de aplicaci√≥n
services.AddInfrastructureLayer();   // Tu capa de infraestructura
```

---

## üß™ Experimento Pr√°ctico

### **Prueba 1: Sin el `using` (Error)**

```csharp
// ‚ùå SIN importar el namespace
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddApplicationLayer(); // ‚ùå Error de compilaci√≥n
```

**Error del compilador:**
```
CS1061: 'IServiceCollection' does not contain a definition for 'AddApplicationLayer' 
and no accessible extension method 'AddApplicationLayer' accepting a first argument 
of type 'IServiceCollection' could be found
```

### **Prueba 2: Con el `using` (Funciona)**

```csharp
// ‚úÖ CON el namespace importado
using Application.DependencyInjection;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddApplicationLayer(); // ‚úÖ Funciona perfectamente
```

---

## üîç Verificaci√≥n en el C√≥digo del Proyecto

### **Ubicaci√≥n de los archivos:**

```
üì¶ EjemploLayeredDIP/
‚îÇ
‚îú‚îÄüìÅ Application/
‚îÇ  ‚îî‚îÄüìÅ DependencyInjection/
‚îÇ     ‚îî‚îÄüìÑ DependencyInjection.cs ‚Üê AQU√ç se define AddApplicationLayer()
‚îÇ
‚îú‚îÄüìÅ Infrastructure/
‚îÇ  ‚îî‚îÄüìÅ DependencyInjection/
‚îÇ     ‚îî‚îÄüìÑ DependencyInjection.cs ‚Üê AQU√ç se define AddInfrastructureLayer()
‚îÇ
‚îî‚îÄüìÅ API/
   ‚îî‚îÄüìÑ Program.cs ‚Üê AQU√ç se USAN ambos m√©todos de extensi√≥n
```

### **En Application/DependencyInjection/DependencyInjection.cs:**
```csharp
namespace Application.DependencyInjection;

public static class DependencyInjection
{
    // "this" hace que sea un m√©todo de extensi√≥n
    public static IServiceCollection AddApplicationLayer(this IServiceCollection services)
    {
        services.AddScoped<IProductService, ProductService>();
        return services;
    }
}
```

### **En API/Program.cs:**
```csharp
// Estos "using" son cruciales - sin ellos, los m√©todos no est√°n disponibles
using Application.DependencyInjection;
using Infrastructure.DependencyInjection;

var builder = WebApplication.CreateBuilder(args);

// Ahora puedes usar los m√©todos de extensi√≥n
builder.Services.AddApplicationLayer();
builder.Services.AddInfrastructureLayer();
```

---

## üìñ Ejemplos Reales en .NET que Usas Todos Los D√≠as

Microsoft usa m√©todos de extensi√≥n en **toda** la plataforma .NET:

### **ASP.NET Core**
```csharp
app.UseRouting();           // M√©todo de extensi√≥n
app.UseAuthentication();    // M√©todo de extensi√≥n
app.UseAuthorization();     // M√©todo de extensi√≥n
app.MapControllers();       // M√©todo de extensi√≥n
```

### **Entity Framework Core**
```csharp
services.AddDbContext<AppDbContext>(options => 
    options.UseSqlServer(connectionString));  // UseSqlServer es m√©todo de extensi√≥n
```

### **Logging**
```csharp
services.AddLogging(builder => 
    builder.AddConsole()      // AddConsole es m√©todo de extensi√≥n
           .AddDebug());      // AddDebug es m√©todo de extensi√≥n
```

### **LINQ (¬°El m√°s famoso!)**
```csharp
var numeros = new[] { 1, 2, 3, 4, 5 };
var pares = numeros.Where(n => n % 2 == 0)    // Where es m√©todo de extensi√≥n
                   .Select(n => n * 2)        // Select es m√©todo de extensi√≥n
                   .ToList();                 // ToList es m√©todo de extensi√≥n
```

---

## üé≠ Analog√≠a: El "Disfraz" del M√©todo

### **Pi√©nsalo as√≠:**

```csharp
// Es como si IServiceCollection tuviera una "m√°scara"
public interface IServiceCollection
{
    // M√©todos reales que S√ç est√°n en la interfaz
    IServiceCollection Add(ServiceDescriptor descriptor);
    
    // Pero AddApplicationLayer() NO est√° aqu√≠
    // Sin embargo, "parece" que s√≠ est√° cuando lo usas
}

// El m√©todo de extensi√≥n es el "disfraz"
public static class DependencyInjection
{
    // Este m√©todo se "disfraza" de m√©todo de IServiceCollection
    public static IServiceCollection AddApplicationLayer(this IServiceCollection services)
    {
        return services;
    }
}

// Cuando escribes:
services.AddApplicationLayer();

// El compilador "levanta el disfraz" y lo convierte en:
DependencyInjection.AddApplicationLayer(services);
```

---

## ‚úèÔ∏è Ejercicio Pr√°ctico para Tus Alumnos

**Desaf√≠o: Crear tu propio m√©todo de extensi√≥n**

```csharp
// 1Ô∏è‚É£ Crea una clase static en un nuevo archivo
namespace MisExtensiones;

public static class StringExtensions
{
    // 2Ô∏è‚É£ Crea un m√©todo static con "this" en el primer par√°metro
    public static string Saludar(this string nombre)
    {
        return $"¬°Hola, {nombre}!";
    }
    
    // 3Ô∏è‚É£ Bonus: M√©todo con par√°metros adicionales
    public static string SaludarEnIdioma(this string nombre, string idioma)
    {
        return idioma.ToLower() switch
        {
            "es" => $"¬°Hola, {nombre}!",
            "en" => $"Hello, {nombre}!",
            "fr" => $"Bonjour, {nombre}!",
            _ => $"¬°Hola, {nombre}!"
        };
    }
}

// 4Ô∏è‚É£ Usar el m√©todo de extensi√≥n
using MisExtensiones;

string nombre = "Carlos";
Console.WriteLine(nombre.Saludar());                    // ¬°Hola, Carlos!
Console.WriteLine(nombre.SaludarEnIdioma("en"));        // Hello, Carlos!
Console.WriteLine(nombre.SaludarEnIdioma("fr"));        // Bonjour, Carlos!

// 5Ô∏è‚É£ Observa: parece que "string" tiene estos m√©todos, ¬°pero no los tiene!
```

---

## üß© Diagrama de Flujo: ¬øC√≥mo Encuentra el Compilador el M√©todo?

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Escribes:                            ‚îÇ
‚îÇ    services.AddApplicationLayer()       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Compilador busca en IServiceCollection‚îÇ
‚îÇ    ¬øTiene AddApplicationLayer()?        ‚îÇ
‚îÇ    ‚ùå NO                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. Compilador busca m√©todos de extensi√≥n‚îÇ
‚îÇ    en los namespaces importados con     ‚îÇ
‚îÇ    "using"                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. Encuentra en                         ‚îÇ
‚îÇ    Application.DependencyInjection:     ‚îÇ
‚îÇ    ‚úÖ AddApplicationLayer(this ...)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. Traduce autom√°ticamente a:           ‚îÇ
‚îÇ    DependencyInjection.AddApplication   ‚îÇ
‚îÇ    Layer(services)                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üî¨ Experimento: Ver la "Traducci√≥n" del Compilador

Puedes usar **ILSpy** o **dotPeek** para ver c√≥mo el compilador traduce tu c√≥digo:

### **C√≥digo que escribes:**
```csharp
builder.Services.AddApplicationLayer();
```

### **C√≥digo compilado (IL) equivalente:**
```csharp
DependencyInjection.AddApplicationLayer(builder.Services);
```

**Herramientas para verificar:**
- [ILSpy](https://github.com/icsharpcode/ILSpy)
- [dotPeek](https://www.jetbrains.com/decompiler/)
- [SharpLab](https://sharplab.io/) (online)

---

## üéØ Reglas Importantes

### ‚úÖ **S√ç Funciona:**
```csharp
// M√©todo de extensi√≥n bien definido
public static IServiceCollection AddLayer(this IServiceCollection services)
{
    return services;
}

// Uso correcto
services.AddLayer();
```

### ‚ùå **NO Funciona:**
```csharp
// Sin "this" - es m√©todo est√°tico normal
public static IServiceCollection AddLayer(IServiceCollection services)
{
    return services;
}

// Esto da error
services.AddLayer(); // ‚ùå Error: no existe este m√©todo en IServiceCollection

// Debes usar as√≠ (menos elegante)
ClaseName.AddLayer(services); // Funciona pero no es fluent
```

### ‚ùå **Tampoco Funciona:**
```csharp
// Definido correctamente pero...
public static IServiceCollection AddLayer(this IServiceCollection services)
{
    return services;
}

// Sin el "using" del namespace
// using MiNamespace; ‚Üê FALTA ESTO

services.AddLayer(); // ‚ùå Error: el compilador no lo encuentra
```

---

## üí° Tips para Recordar

### **Mnemot√©cnico: "T.E.S.U."**

1. **T**his - Debe tener `this` en el primer par√°metro
2. **E**static - La clase y el m√©todo deben ser `static`
3. **S**yntax sugar - Es az√∫car sint√°ctico del compilador
4. **U**sing - Necesitas el `using` del namespace

### **Regla del Pulgar:**

```csharp
public static ReturnType NombreMetodo(this TipoAExtender parametro)
           ‚Üë              ‚Üë            ‚Üë         ‚Üë
        static      cualquier      CLAVE    tipo que
                    nombre                  extiendes
```

---

## üìä Comparativa Visual

| Aspecto | M√©todo Est√°tico Normal | M√©todo de Extensi√≥n |
|---------|----------------------|-------------------|
| **Clase** | `static class` | `static class` |
| **M√©todo** | `static` | `static` |
| **Primer par√°metro** | `Tipo param` | `this Tipo param` |
| **Llamada** | `Clase.Metodo(obj)` | `obj.Metodo()` |
| **Legibilidad** | Media | Alta (fluent) |
| **Necesita using** | No | S√≠ |
| **Method chaining** | Dif√≠cil | F√°cil |

---

## üéì Preguntas Frecuentes de Estudiantes

### **P: ¬øPor qu√© no veo IntelliSense para mi m√©todo de extensi√≥n?**
**R:** Verifica que:
1. Importaste el namespace con `using`
2. La clase es `static`
3. El m√©todo es `static`
4. El primer par√°metro tiene `this`

### **P: ¬øPuedo extender tipos sealed como `string` o `int`?**
**R:** ¬°S√≠! Los m√©todos de extensi√≥n funcionan con cualquier tipo:
```csharp
public static bool EsPar(this int numero)
{
    return numero % 2 == 0;
}

// Uso
int num = 4;
bool resultado = num.EsPar(); // true
```

### **P: ¬øLos m√©todos de extensi√≥n pueden acceder a miembros privados?**
**R:** No. Solo pueden usar miembros p√∫blicos del tipo que extienden.

### **P: ¬øQu√© pasa si hay un m√©todo con el mismo nombre en la clase original?**
**R:** El m√©todo de la clase original tiene prioridad. El m√©todo de extensi√≥n solo se usa si no existe uno con el mismo nombre en la clase.

---

## üåü Conclusi√≥n

Los m√©todos de extensi√≥n son **az√∫car sint√°ctico** que:

‚úÖ Hacen el c√≥digo m√°s legible  
‚úÖ Permiten dise√±o de APIs fluidas (Fluent API)  
‚úÖ Organizan c√≥digo de configuraci√≥n por capas  
‚úÖ Siguen el est√°ndar de .NET Framework  
‚úÖ Facilitan el patr√≥n de Dependency Injection  

**Recuerda:** Cuando ves `services.AddApplicationLayer()`, el compilador lo traduce internamente a `DependencyInjection.AddApplicationLayer(services)`. ¬°Es magia de C#!

---

## üìö Referencias Oficiales

- [Extension Methods - Microsoft Docs](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)
- [Using Directive - Microsoft Docs](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive)
- [C# Language Specification - Extension Methods](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/classes#extension-methods)
- [Dependency Injection in .NET](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection)

---

üìå **Archivo creado para el proyecto educativo de Dependency Injection por Capas**
